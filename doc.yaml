UM ‚Äì Prioritization (Golden Record)
Context

We have multiple external sources (RPMM, OSR, RCX).
All data is stored in a unified NORMALIZE model.

Each source is matched independently, and equivalent entities are grouped into clusters.

We need an API to compute the best values for each entity, based on:

the sources present in the cluster,

business priority rules.

Global idea (simple)

The system works at cluster level.

A cluster represents the same entity coming from different sources.

The API:

looks at all entities in the cluster,

identifies which sources are present,

and selects the best value for each field.

How it works (high level)

When the API is called:

We read the matching table to get all entities in the same cluster

We count the distinct sources in this cluster

These sources define the scope of prioritization

We extract candidate values from NORMALIZE

We apply priority rules

We return / store the certified values

Simple schema (mental model)
Client
  |
  v
API Prioritization
  |
  v
Matching table
  |
  v
Cluster (list of sources)
  |
  v
Normalize
  |
  v
Priority rules
  |
  v
Certified values

Example (very concrete)
Matching table

Cluster CL_42:

cluster_id	source	src_id
CL_42	OSR	123
CL_42	RPMM	908
CL_42	RCX	77

So:

sources_in_cluster = {OSR, RPMM, RCX}

Normalize (legal_name)
source	src_id	legal_name
OSR	123	BNP PARIBAS
RCX	77	BNP PARIBAS SA
RPMM	908	NULL
Priority rules
field	source	rank
legal_name	RCX	1
legal_name	OSR	2
legal_name	RPMM	3
Result

The API returns:

legal_name = "BNP PARIBAS SA"
source = RCX

Why cluster is important

The cluster defines which sources are compared.

We never compare:

RCX with Bloomberg

or OSR with a source that is not in the cluster

We only compare:

sources that really represent the same entity.

This makes the prioritization:

correct

local

efficient

Performance principle

The API never scans all data.

It only works on:

entities inside one cluster


So the cost depends on:

cluster size
not on:

total volume of NORMALIZE

This makes the system fast and scalable.

Summary (in one sentence)

The API takes a cluster, looks at the sources inside it, and selects the best value for each field using business priority rules.

(Optional ‚Äì future optimization)

We could store a table like:

CERTIFIED_PROVENANCE
(cert_id, field, source)


So we can skip recalculation if a new source is less prioritary.

This is only an optimization layer, not required for the first version.

Pourquoi ce format est exactement ce que tu veux

Parce que l√† on est :

m√™me style que ton screenshot

anglais simple

phrases courtes

pas de jargon inutile

sch√©ma mental clair

lisible par :

dev backend

data engineer

product

manager

C‚Äôest typiquement le style qu‚Äôon trouve dans :

bons repos Git

docs d‚Äô√©quipes plateforme

specs d‚ÄôAPI propres

Et surtout :
üëâ quelqu‚Äôun peut lire en 2 minutes et dire ‚Äúok j‚Äôai compris comment √ßa marche‚Äù.
