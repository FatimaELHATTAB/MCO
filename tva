from __future__ import annotations
from typing import List, Tuple
import polars as pl

from src.core.db_client import DBClient
from src.core.exact_matcher import ExactMatcher
from src.core.rules_loader import load_provider_config


def _check_required_columns(df: pl.DataFrame, required: List[str], *, side: str, level_name: str) -> Tuple[bool, List[str]]:
    """Vérifie que les colonnes requises existent dans le DataFrame."""
    missing = [c for c in required if c not in df.columns]
    return (len(missing) == 0, missing)


class MatchingPipeline:
    """
    Pipeline provider-first minimal :
      - lecture RMPM + provider depuis la DB
      - itération des niveaux exacts (matching_criterias)
      - concatenation des résultats
    Sans tie-break (sera ajouté plus tard).
    """

    def __init__(self, db: DBClient, matcher: ExactMatcher | None = None):
        self.db = db
        self.matcher = matcher or ExactMatcher()

    def run(self, provider: str) -> pl.DataFrame:
        cfg = load_provider_config(provider)

        # 1) Lecture des tables (aucun renommage)
        rmpm_df = self.db.read_table("normalized.rmpm")
        prov_df = self.db.read_table(cfg["source"]["table"], where=cfg["source"].get("where"))

        results: List[pl.DataFrame] = []

        # 2) Itération des niveaux
        levels = cfg["matching_criterias"]
        # préserver l'ordre humain: level1, level1bis, level2, ...
        order = sorted(levels.keys(), key=lambda k: ((int("".join([x for x in k if x.isdigit()]) or "0")), k))

        for lvl_name in order:
            rule = levels[lvl_name]
            left_keys = rule["rmpm"]
            right_keys = rule["provider"]

            # Vérif colonnes
            ok_left, miss_left = _check_required_columns(rmpm_df, left_keys, side="rmpm", level_name=lvl_name)
            ok_right, miss_right = _check_required_columns(prov_df, right_keys, side="provider", level_name=lvl_name)
            if not ok_left or not ok_right:
                # On skippe proprement ce niveau, mais on laisse une trace minimale (colonne tmp)
                continue

            # 3) Matching exact
            matched = self.matcher.match(
                rmpm_df, prov_df,
                level_name=lvl_name,
                left_keys=left_keys,
                right_keys=right_keys,
            )
            results.append(matched)

        if not results:
            return pl.DataFrame()  # rien de matché

        # 4) Concat sans tie-break (on verra ensuite)
        final_df = pl.concat(results, how="vertical_relaxed")
        return final_df
